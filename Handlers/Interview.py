from Keyboards import interview_kb
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from create_bot import bot, dp
from aiogram import types
from aiogram.dispatcher import Dispatcher
# from ..interview_data import interview_data

interview_data = {
    'Sql': 'SELECT * FROM "table" WHERE "id" IN(5, 6, 7, 8, 9)',
    'Orm': '''
– кэшированные Foreign Key id
– select_related для ForeignKey (указывает Django, какие связанные модели мы хотим, чтобы он мог заранее выполнить JOINs.)
– prefetch_related для полей ManyToMany (Django сначала получает все сообщения Post, а затем запускает другой SQL-запрос, который извлекает все связи.)
– Настройка Prefetch (иногда prefetch_related недостаточно, чтобы Django не выполнял дополнительные запросы)
    ''',
    'Http': '''
OPTIONS - возможностей веб-сервера или параметров соединения («*». Запросы «OPTIONS * HTTP/1.1)
GET - получение данных (можно также начать какой-либо процесс)
HEAD - Аналогичен методу GET, но в ответе сервера отсутствует тело (обычно для извлечения метаданных)
POST - добавление или замена данных
PUT - обновление данных
PATCH - Аналогично PUT, но применяется только к фрагменту ресурса
DELETE - удаление данных
TRACE - Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе
CONNECT - Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.
Различие методов POST и PUT:
POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. 
Используя PUT предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.
Сообщения ответов сервера на метод PUT не кэшируются.''',

    'Code': '''
Информационные 100
Успешные 200
Перенаправления 300
Клиентские ошибки 400
Серверные ошибки 500''',

    '100': '''
100	Continue "Продолжить" - запрос успешно принят и клиент может продолжать присылать запросы или проигнорировать.	
101	Switching Protocol	"Переключение протокола". Этот код присылается в ответ на запрос клиента, содержащий заголовок Upgrade:, и указывает, что сервер переключился на протокол, который был указан в заголовке. Эта возможность позволяет перейти на несовместимую версию протокола и обычно не используется.	
102	Processing	"В обработке" - сервер получил запрос и обрабатывает его, но обработка ещё не завершена.	
103	Early Hints	"Ранние подсказки". В ответе сообщаются ресурсы, которые могут быть загружены заранее, пока сервер будет подготавливать основной ответ. ''',
    '200': '''200 "Успешно". Запрос успешно обработан. Что значит "успешно", зависит от метода HTTP, который был запрошен:
GET: "ПОЛУЧИТЬ". Запрошенный ресурс был найден и передан в теле ответа.
HEAD: "ЗАГОЛОВОК". Заголовки переданы в ответе.
POST: "ПОСЫЛКА". Ресурс, описывающий результат действия сервера на запрос, передан в теле ответа.
TRACE: "ОТСЛЕЖИВАТЬ". Тело ответа содержит тело запроса полученного сервером.
201	Created	"Создано". Запрос успешно выполнен и в результате был создан ресурс. Этот код обычно присылается в ответ на запрос PUT "ПОМЕСТИТЬ".	
202	Accepted "Принято". Запрос принят, но ещё не обработан. Не поддерживаемо, т.е., нет способа с помощью HTTP отправить асинхронный ответ позже, который будет показывать итог обработки запроса. Это предназначено для случаев, когда запрос обрабатывается другим процессом или сервером, либо для пакетной обработки.	
203	Non-Authoritative Information	"Информация не авторитетна" – информация, которая возвращена, была предоставлена не от исходного сервера, а из какого-нибудь другого источника. Во всех остальных ситуациях более предпочтителен код ответа 200 OK.	
204	No Content	"Нет содержимого". Нет содержимого для ответа на запрос, но заголовки ответа, которые могут быть полезны, присылаются. Клиент может использовать их для обновления кешированных заголовков полученных ранее для этого ресурса.	
205	Reset Content	"Сбросить содержимое". Этот код присылается, когда запрос обработан, чтобы сообщить клиенту, что необходимо сбросить отображение документа, который прислал этот запрос.	
206	Partial Content	"Частичное содержимое". Этот код ответа используется, когда клиент присылает заголовок диапазона, чтобы выполнить загрузку отдельно, в несколько потоков.	''',
    '300': '''300	Multiple Choice	"Множественный выбор" – запрос имеет более чем один из возможных ответов. И User-agent или пользователь должен выбрать один из ответов. Не существует стандартизированного способа выбора одного из полученных ответов.
301	Moved Permanently "Перемещён на постоянной основе". Этот код ответа значит, что URI запрашиваемого ресурса был изменён. Возможно, новый URI будет предоставлен в ответе.
302	Found "Найдено" – запрошенный ресурс временно изменён.
303	See Other "Просмотр других ресурсов". Этот код ответа присылается, чтобы направлять клиента для получения запрашиваемого ресурса в другой URI с запросом GET.
304	Not Modified "Не модифицировано". Используется для кеширования. Это код ответа значит, что запрошенный ресурс не был изменён. Таким образом, клиент может продолжать использовать кешированную версию ответа.


    ''',
    '400': '''
400	Bad Request	"Плохой запрос" – сервер не понимает запрос из-за неверного синтаксиса.	''',
    '500': '''
500	"Внутренняя ошибка сервера". Сервер столкнулся с ситуацией, которую он не знает как обработать.	
501	"Не реализовано". Метод запроса не поддерживается сервером и не может быть обработан. GET и HEAD.
502	"Плохой шлюз" – сервер, во время работы в качестве шлюза для получения ответа, нужного для обработки запроса, получил недействительный (недопустимый) ответ.	
503	"Сервис недоступен". Сервер не готов обрабатывать запрос. причины: отключение сервера или то, что он перегружен.	
504	сервер действует как шлюз и не может получить ответ вовремя.
505 HTTP-версия, используемая в запросе, не поддерживается сервером.''',
    'Rest': 'REST — это набор правил как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать.',
    "Mixin": '''Mixin классы - это классы у которых нет данных, но есть методы. Mixin используются для предоставления реализации методов для повторного использования дочерними классами.
С одной стороны, то же самое можно сделать с помощью наследования обычных классов, но не всегда те методы, которые нужны в разных дочерних классах, имеют смысл в родительском

Он представляет ограниченную форму множественного наследования и родительский класс, который просто даёт функциональные возможности подклассам, не содержит состояния и не предназначен для создания экземпляров.'''
}

class FSMinterview(StatesGroup):
    question = State()


async def interview(message: types.Message):
    await FSMinterview.question.set()
    await bot.send_message(message.from_user.id, 'Lets go', reply_markup=interview_kb)


async def get_response(message: types.Message, state: FSMContext):
    if message.text in ['Конец', '/конец', 'End', 'end']:
        await bot.send_message(message.from_user.id, 'Game over')
        await state.finish()
    else:
        await bot.send_message(message.from_user.id, interview_data[message.text.capitalize()])


async def finish_interview(message: types.Message, state: FSMContext):
    await bot.send_message(message.from_user.id, 'Game over')
    await state.finish()


def register_handlers_interview(dp: Dispatcher):
    dp.register_message_handler(interview,
                                commands=['interview', 'Собеседование', 'собеседование', 'interview', 'Interview'],
                                state=None)
    dp.register_message_handler(get_response, state=FSMinterview.question)